<label for="date-input">Select Day:</label>
<input type="date" id="date-input" name="date-input">

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0'); 

    const dateInput = document.getElementById('date-input');


    dateInput.min = `${year}-${month}-01`;
    dateInput.max = `${year}-${month}-31`; // Maximum nap 31, de a böngésző automatikusan kezeli a hónap hosszát


    dateInput.value = `${year}-${month}-${day}`;
  });
</script>


//spring boot

package com.example.demo.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class HelloWorldController {

    @GetMapping("/hello")
    public String sayHello() {
        return "Hello from Java backend!";
    }
}


//cors
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:4200")  // Angular alkalmazás URL-je
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}

httpclientmodule import app-ba

ng generate service data
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {

  private apiUrl = 'http://localhost:8080/api/hello';

  constructor(private http: HttpClient) { }

  getHelloMessage(): Observable<string> {
    return this.http.get(this.apiUrl, { responseType: 'text' });
  }
}

import { Component, OnInit } from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'app-root',
  template: `<h1>{{ message }}</h1>`,
})
export class AppComponent implements OnInit {
  message: string;

  constructor(private dataService: DataService) {}

  ngOnInit(): void {
    this.dataService.getHelloMessage().subscribe(response => {
      this.message = response;
    });
  }
}

///

<form [formGroup]="uploadForm" (ngSubmit)="onSubmit()">
  <input type="file" formControlName="file" (change)="onFileSelect($event)" />
  <button type="submit">Upload</button>
</form>

import { Component } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html',
})
export class FileUploadComponent {
  uploadForm: FormGroup;
  selectedFile: File;

  constructor(private formBuilder: FormBuilder, private http: HttpClient) {
    this.uploadForm = this.formBuilder.group({
      file: ['']
    });
  }

  onFileSelect(event) {
    this.selectedFile = event.target.files[0];
  }

  onSubmit() {
    const formData = new FormData();
    formData.append('file', this.selectedFile);

    this.http.post('http://localhost:8080/upload', formData).subscribe(
      (response) => console.log(response),
      (error) => console.error(error)
    );
  }
}

spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB


//filet elkuldi backendnek

import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html',
})
export class FileUploadComponent {
  constructor(private http: HttpClient) {}

  createAndSendFile() {
    // Fájl tartalma
    const fileContent = 'Ez egy teszt fájl tartalma.';
    
    // Fájl létrehozása Blob segítségével
    const blob = new Blob([fileContent], { type: 'text/plain' });

    // Fájl névvel való ellátása
    const file = new File([blob], 'testfile.txt', { type: 'text/plain' });

    // FormData létrehozása és a fájl hozzáadása
    const formData = new FormData();
    formData.append('file', file);

    // Fájl elküldése a backendre
    this.http.post('http://localhost:8080/upload', formData).subscribe(
      (response) => console.log(response),
      (error) => console.error(error)
    );
  }
}


<button (click)="createAndSendFile()">Create and Upload File</button>


@PostMapping("/upload")
public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {
    if (file.isEmpty()) {
        return new ResponseEntity<>("Please select a file to upload", HttpStatus.BAD_REQUEST);
    }

    try {
        byte[] bytes = file.getBytes();
        Path path = Paths.get("uploads/" + file.getOriginalFilename());
        Files.write(path, bytes);

        return new ResponseEntity<>("File uploaded successfully: " + file.getOriginalFilename(), HttpStatus.OK);
    } catch (IOException e) {
        return new ResponseEntity<>("File upload failed: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

//append

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@RestController
public class FileUploadController {

    private static final String UPLOAD_DIR = "uploads/";
    private static final String TARGET_FILE_NAME = "merged_file.txt"; // A cél fájl neve

    @PostMapping("/upload")
    public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {
        if (file.isEmpty()) {
            return new ResponseEntity<>("Please select a file to upload", HttpStatus.BAD_REQUEST);
        }

        try {
            // Cél fájl elérési útvonala
            Path targetPath = Paths.get(UPLOAD_DIR + TARGET_FILE_NAME);
            
            // Ha a fájl nem létezik, létrehozzuk
            if (!Files.exists(targetPath)) {
                Files.createFile(targetPath);
            }

            // Fájl tartalmának hozzáfűzése a meglévő fájlhoz
            try (FileOutputStream fos = new FileOutputStream(new File(targetPath.toString()), true)) {
                fos.write(file.getBytes());
                fos.write(System.lineSeparator().getBytes()); // Új sor hozzáadása minden egyes fájl végén
            }

            return new ResponseEntity<>("File content appended successfully to: " + TARGET_FILE_NAME, HttpStatus.OK);
        } catch (IOException e) {
            return new ResponseEntity<>("File upload failed: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}

//parse

import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class MyService {

  constructor(private http: HttpClient) { }

  sendData() {
    const headers = new HttpHeaders({ 'Content-Type': 'text/plain' });
    const body = '1;1;1';

    this.http.post('http://localhost:8080/api/postsofor', body, { headers, responseType: 'text' })
      .subscribe(
        response => {
          console.log('Response:', response);
        },
        error => {
          console.error('Error:', error);
        }
      );
  }
}

//vissza kuldes

import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class FileController {

    @GetMapping("/download-file")
    public ResponseEntity<Resource> downloadFile() {
        try {
            // Fájl betöltése az erőforrások közül (pl. classpath-ból)
            Resource file = new ClassPathResource("static/sample.txt");

            // HTTP válasz beállítása: fájl küldése szöveges típusúként
            return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + file.getFilename() + "\"")
                .body(file);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
}


import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class FileController {

    @GetMapping("/download-file")
    public ResponseEntity<Resource> downloadFile() {
        try {
            Resource file = new ClassPathResource("static/sample.txt");

            return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + file.getFilename() + "\"")
                .body(file);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
}

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class FileDownloadService {

  constructor(private http: HttpClient) { }

  downloadFileContent() {
    this.http.get('http://localhost:8080/api/download-file', { responseType: 'blob' })
      .subscribe(
        (response: Blob) => {
          this.readFileContent(response);
        },
        error => {
          console.error('Error downloading file:', error);
        }
      );
  }

  // Fájl tartalmának beolvasása változóba
  private readFileContent(blob: Blob) {
    const reader = new FileReader();
    reader.onload = () => {
      const fileContent = reader.result as string;  // A fájl tartalma stringként
      console.log('File content:', fileContent);    // Itt dolgozhatsz a tartalommal
    };
    reader.readAsText(blob);  // Ha a fájl szöveg, használjuk a readAsText metódust
  }
}

//fileba ira

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Arrays;

public class FileWriteExample {
    public static void main(String[] args) {
        Path filePath = Paths.get("output.txt");  // Fájl elérési útvonala

        // Adatok, amelyeket írni szeretnénk
        List<String> lines = Arrays.asList("Sor 1", "Sor 2", "Sor 3");

        try {
            // Írás a fájlba
            Files.write(filePath, lines, StandardCharsets.UTF_8);
            System.out.println("Fájlba írás sikeres!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

//file feltoltes

// file-upload.interface.ts
export interface FileUpload {
  file1: string;  // Base64 formátumban az első fájl
  file2: string;  // Base64 formátumban a második fájl
}


<form (submit)="onSubmit()">
  <label for="file1">Fájl 1:</label>
  <input type="file" id="file1" (change)="onFileSelected($event, 'file1')" />

  <label for="file2">Fájl 2:</label>
  <input type="file" id="file2" (change)="onFileSelected($event, 'file2')" />

  <button type="submit">Fájlok elküldése</button>
</form>

// file-upload.component.ts
import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { FileUpload } from './file-upload.interface';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html'
})
export class FileUploadComponent {
  fileData: FileUpload = { file1: '', file2: '' };

  constructor(private http: HttpClient) {}

  onFileSelected(event: Event, fileTag: string): void {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files[0]) {
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = () => {
        const base64String = reader.result as string;
        if (fileTag === 'file1') {
          this.fileData.file1 = base64String.split(',')[1]; // Base64 tartalom leválasztása
        } else if (fileTag === 'file2') {
          this.fileData.file2 = base64String.split(',')[1];
        }
      };
      reader.readAsDataURL(file); // Base64-re konvertálás
    }
  }

  onSubmit(): void {
    this.http.post('http://localhost:8080/api/upload', this.fileData)
      .subscribe(response => {
        console.log('Fájlok sikeresen elküldve!', response);
      }, error => {
        console.error('Hiba a fájlok elküldésekor:', error);
      });
  }
}

// FileUploadDto.java
public class FileUploadDto {
    private String file1;
    private String file2;

    // Getters and setters
    public String getFile1() {
        return file1;
    }

    public void setFile1(String file1) {
        this.file1 = file1;
    }

    public String getFile2() {
        return file2;
    }

    public void setFile2(String file2) {
        this.file2 = file2;
    }
}

// FileUploadController.java
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class FileUploadController {

    @PostMapping("/upload")
    public ResponseEntity<String> uploadFiles(@RequestBody FileUploadDto fileUploadDto) {
        // A fájlok feldolgozása itt történik
        System.out.println("File 1 (Base64): " + fileUploadDto.getFile1());
        System.out.println("File 2 (Base64): " + fileUploadDto.getFile2());

        // Például a fájlokat kiírhatjuk a fájlrendszerbe vagy adatbázisba menthetjük
        // Base64-dekódolásra is szükség lehet (nem mutatott itt)

        return ResponseEntity.ok("Fájlok sikeresen fogadva!");
    }
}

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Base64;

@RestController
@RequestMapping("/api")
public class FileUploadController {

    @PostMapping("/upload")
    public ResponseEntity<String> uploadFiles(@RequestBody FileUploadDto fileUploadDto) {
        try {
            // Fájl 1 dekódolása és mentése
            byte[] decodedFile1 = Base64.getDecoder().decode(fileUploadDto.getFile1());
            try (FileOutputStream fos = new FileOutputStream("output_file1.txt")) {
                fos.write(decodedFile1);
            }

            // Fájl 2 dekódolása és mentése
            byte[] decodedFile2 = Base64.getDecoder().decode(fileUploadDto.getFile2());
            try (FileOutputStream fos = new FileOutputStream("output_file2.txt")) {
                fos.write(decodedFile2);
            }

            System.out.println("Fájlok sikeresen mentve!");

            return ResponseEntity.ok("Fájlok sikeresen fogadva és mentve!");

        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(500).body("Hiba történt a fájlok mentésekor.");
        }
    }
}

//h

<!-- file-upload.component.html -->
<form>
  <label for="file1">Fájl 1:</label>
  <input type="file" id="file1" (change)="onFileSelected($event, 'file1')" />

  <label for="file2">Fájl 2:</label>
  <input type="file" id="file2" (change)="onFileSelected($event, 'file2')" />

  <!-- A submit gomb csak akkor jelenik meg, ha mindkét fájl fel van töltve -->
  <button *ngIf="bothFilesUploaded()" (click)="onSubmit()">Fájlok elküldése</button>
</form>

// file-upload.component.ts
import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { FileUpload } from './file-upload.interface';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html'
})
export class FileUploadComponent {
  fileData: FileUpload = { file1: '', file2: '' };

  constructor(private http: HttpClient) {}

  // Fájlfeltöltés kezelése
  onFileSelected(event: Event, fileTag: string): void {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files[0]) {
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = () => {
        const base64String = reader.result as string;
        if (fileTag === 'file1') {
          this.fileData.file1 = base64String.split(',')[1]; // Base64 tartalom leválasztása
        } else if (fileTag === 'file2') {
          this.fileData.file2 = base64String.split(',')[1];
        }
      };
      reader.readAsDataURL(file); // Base64 konvertálás
    }
  }

  // Ellenőrzi, hogy mindkét fájl fel van-e töltve
  bothFilesUploaded(): boolean {
    return this.fileData.file1 !== '' && this.fileData.file2 !== '';
  }

  // Adatok elküldése a backendnek
  onSubmit(): void {
    this.http.post('http://localhost:8080/api/upload', this.fileData)
      .subscribe(response => {
        console.log('Fájlok sikeresen elküldve!', response);
      }, error => {
        console.error('Hiba a fájlok elküldésekor:', error);
      });
  }
}

import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html'
})
export class FileUploadComponent {
  file1: string = ''; // Az első fájl Base64 formátumban
  file2: string = ''; // A második fájl Base64 formátumban

  constructor(private http: HttpClient) {}

  // Fájlfeltöltés kezelése
  onFileSelected(event: Event): void {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files[0]) {
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = () => {
        const base64String = reader.result as string;

        // Ha még nincs fájl feltöltve, az első fájlként tároljuk
        if (!this.file1) {
          this.file1 = base64String.split(',')[1]; // Base64 tartalom leválasztása
        } else if (!this.file2) {
          // Ha már van egy fájl feltöltve, a második fájlként tároljuk
          this.file2 = base64String.split(',')[1];
        }
      };
      reader.readAsDataURL(file);
    }
  }

  // Ellenőrzi, hogy mindkét fájl fel van-e töltve
  bothFilesUploaded(): boolean {
    return this.file1 !== '' && this.file2 !== '';
  }

  // Adatok elküldése a backendnek
  onSubmit(): void {
    const fileData = {
      file1: this.file1,
      file2: this.file2
    };

    this.http.post('http://localhost:8080/api/upload', fileData)
      .subscribe(response => {
        console.log('Fájlok sikeresen elküldve!', response);
      }, error => {
        console.error('Hiba a fájlok elküldésekor:', error);
      });
  }
}

<!-- file-upload.component.html -->
<form>
  <label for="file">Válassz fájlokat:</label>
  <input type="file" id="file" (change)="onFileSelected($event)" multiple />

  <!-- A submit gomb csak akkor jelenik meg, ha mindkét fájl fel van töltve -->
  <button *ngIf="bothFilesUploaded()" (click)="onSubmit()">Fájlok elküldése</button>
</form>


//k

import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

public class StringFormatValidator {

    // Regex to match a valid date in format YYYY-MM-DD
    private static final Pattern YEAR_PATTERN = Pattern.compile("\\d{4}-\\d{2}-\\d{2}");
    
    // Method to validate the entire string structure
    public boolean validate(String input) {
        // Split input by semicolons
        String[] parts = input.split(";");

        if (parts.length != 4) {
            return false; // Ensure the input has exactly 4 parts
        }

        // Validate first part: a list of year strings
        if (!parts[0].startsWith("[") || !parts[0].endsWith("]")) {
            return false;
        }
        String firstPartContent = parts[0].substring(1, parts[0].length() - 1); // Remove square brackets
        List<String> firstPart = Arrays.asList(firstPartContent.split(","));
        for (String year : firstPart) {
            if (!YEAR_PATTERN.matcher(year.trim()).matches()) {
                return false; // Each item should be a valid year in YYYY-MM-DD format
            }
        }

        // Validate second part: a list of integers
        if (!parts[1].startsWith("[") || !parts[1].endsWith("]")) {
            return false;
        }
        String secondPartContent = parts[1].substring(1, parts[1].length() - 1); // Remove square brackets
        List<String> secondPart = Arrays.asList(secondPartContent.split(","));
        for (String number : secondPart) {
            try {
                Integer.parseInt(number.trim()); // Each item should be a valid integer
            } catch (NumberFormatException e) {
                return false;
            }
        }

        // Validate third part: a single integer
        try {
            Integer.parseInt(parts[2].trim());
        } catch (NumberFormatException e) {
            return false;
        }

        // Validate fourth part: a single year in YYYY-MM-DD format
        if (!YEAR_PATTERN.matcher(parts[3].trim()).matches()) {
            return false;
        }

        // If all checks pass, return true
        return true;
    }

    public static void main(String[] args) {
        StringFormatValidator validator = new StringFormatValidator();
        
        // Example input
        String validInput = "[2003-01-01, 2004-01-01];[11];1;2004-01-01";
        
        boolean isValid = validator.validate(validInput);
        System.out.println("Is valid: " + isValid); // Should print true or false based on validation
    }
}

//error

public class MessageService {
    public String getMessage() {
        return "Üdvözlünk az alkalmazásban!";
    }
}

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MessageController {

    private final MessageService messageService;

    // Konstruktor-injektálás
    public MessageController(MessageService messageService) {
        this.messageService = messageService;
    }

    @GetMapping("/message")
    public String getMessage() {
        // Meghívja a MessageService osztály metódusát
        return messageService.getMessage();
    }
}

import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-message',
  templateUrl: './message.component.html',
})
export class MessageComponent {
  message: string = '';  // Eltároljuk a backendtől kapott üzenetet
  errorMessage: string = '';  // Hibakezeléshez

  constructor(private http: HttpClient) {}

  getMessage() {
    this.http.get('/api/message', { responseType: 'text' }).subscribe(
      (data) => {
        this.message = data;  // A visszakapott stringet eltároljuk
      },
      (error) => {
        this.errorMessage = 'Hiba történt az üzenet lekérésekor';  // Hibakezelés
      }
    );
  }
}

<div *ngIf="message">
  <h3>Backend üzenet:</h3>
  <p>{{ message }}</p>
</div>

<div *ngIf="errorMessage" class="alert alert-danger">
  {{ errorMessage }}
</div>

<button (click)="getMessage()">Üzenet lekérése</button>


//cs

import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-message',
  templateUrl: './message.component.html',
})
export class MessageComponent {
  message: string = ''; // A backendtől kapott üzenet
  errorMessage: string = ''; // Hibakezeléshez

  constructor(private http: HttpClient) {}

  getMessage() {
    this.message = ''; // Mindig ürítsd ki a message-t és az error-t, mielőtt új kérést küldesz
    this.errorMessage = '';

    this.http.get('/api/message', { responseType: 'text' }).subscribe(
      (data) => {
        this.message = data; // Sikeres válasz esetén eltároljuk az üzenetet
      },
      (error) => {
        this.errorMessage = 'Hiba történt az üzenet lekérésekor'; // Hibakezelés
      }
    );
  }
}

loading: boolean = false;

getMessage() {
  this.message = '';
  this.errorMessage = '';
  this.loading = true;  // Kérés folyamatban

  this.http.get('/api/message', { responseType: 'text' }).subscribe(
    (data) => {
      this.message = data;
      this.loading = false;  // Kérés befejeződött
    },
    (error) => {
      this.errorMessage = 'Hiba történt az üzenet lekérésekor';
      this.loading = false;  // Kérés befejeződött
    }
  );
}
<div *ngIf="loading">Kérés folyamatban...</div>

//value

public class FeForras {
    private String string1;
    private String string2;

    public FeForras(String string1, String string2) {
        this.string1 = string1;
        this.string2 = string2;
    }

    public String getString1() {
        return string1;
    }

    public String getString2() {
        return string2;
    }

    // Az egyenlőség ellenőrzéséhez szükség van a equals és hashCode felüldefiniálására
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FeForras feForras = (FeForras) o;
        return string1.equals(feForras.string1) && string2.equals(feForras.string2);
    }

    @Override
    public int hashCode() {
        return Objects.hash(string1, string2);
    }
}


import java.util.HashMap;
import java.util.Map;

public class FeForrasManager {
    // Statikus Map, ahol a kulcs egy int, és az érték egy FeForras objektum
    private static Map<Integer, FeForras> feForrasMap = new HashMap<>();
    private static int currentIndex = 0; // Ez a kulcs, amit automatikusan növelünk

    // Ez a metódus kezeli a hozzáadást
    public static int addFeForras(FeForras newFeForras) {
        // Megnézzük, hogy az adott FeForras már létezik-e a map-ben
        for (Map.Entry<Integer, FeForras> entry : feForrasMap.entrySet()) {
            if (entry.getValue().equals(newFeForras)) {
                // Ha létezik, visszatérünk annak a kulcsával (index)
                return entry.getKey();
            }
        }

        // Ha nem létezik, új kulccsal adjuk hozzá
        feForrasMap.put(currentIndex, newFeForras);
        return currentIndex++; // Visszaadjuk az új kulcsot, majd növeljük az indexet
    }

    // Opcionálisan egy getter a Map-hez, ha meg szeretnéd nézni a tartalmát
    public static Map<Integer, FeForras> getFeForrasMap() {
        return feForrasMap;
    }
}

public class Main {
    public static void main(String[] args) {
        FeForras fe1 = new FeForras("string1", "string2");
        FeForras fe2 = new FeForras("string1", "string2");
        FeForras fe3 = new FeForras("string3", "string4");

        // Első hozzáadás
        int index1 = FeForrasManager.addFeForras(fe1);
        System.out.println("fe1 index: " + index1); // 0

        // Második hozzáadás (ugyanaz, mint fe1, tehát nem adja hozzá újra)
        int index2 = FeForrasManager.addFeForras(fe2);
        System.out.println("fe2 index: " + index2); // 0 (ugyanaz az index, mint fe1)

        // Harmadik hozzáadás (új érték)
        int index3 = FeForrasManager.addFeForras(fe3);
        System.out.println("fe3 index: " + index3); // 1
    }
}


//tabla

data.service.ts

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private fileContent: string = '';

  // Beállítjuk a fájl tartalmát
  setFileContent(content: string) {
    this.fileContent = content;
  }

  // Visszakapjuk a fájl tartalmát
  getFileContent() {
    return this.fileContent;
  }
}


import { Component } from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'app-file-input',
  templateUrl: './file-input.component.html'
})
export class FileInputComponent {
  constructor(private dataService: DataService) {}

  ngOnInit() {
    // Például itt beállítjuk a fájl tartalmát
    const fileData = '1;1;2000-01-01;0;0\n2;2;2001-02-02;1;1';
    this.dataService.setFileContent(fileData);
  }
}


megjelenites

import { Component, OnInit } from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'app-dynamic-table',
  templateUrl: './dynamic-table.component.html'
})
export class DynamicTableComponent implements OnInit {
  tableData: any[] = [];

  constructor(private dataService: DataService) {}

  ngOnInit() {
    // Lekérjük a fájl tartalmát és feldolgozzuk
    const fileContent = this.dataService.getFileContent();
    this.tableData = this.parseFileContent(fileContent);
  }

  // A fájl tartalmának feldolgozása
  parseFileContent(content: string): any[] {
    const rows = content.split('\n'); // Sorokra bontjuk a fájlt
    return rows.map(row => row.split(';')); // Minden sort oszlopokra bontunk
  }
}


<table>
  <thead>
    <tr>
      <th>Column 1</th>
      <th>Column 2</th>
      <th>Column 3</th>
      <th>Column 4</th>
      <th>Column 5</th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let row of tableData">
      <td *ngFor="let cell of row">{{ cell }}</td>
    </tr>
  </tbody>
</table>

//modositas


import { Component, OnInit } from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'app-dynamic-table',
  templateUrl: './dynamic-table.component.html'
})
export class DynamicTableComponent implements OnInit {
  tableData: any[] = [];

  constructor(private dataService: DataService) {}

  ngOnInit() {
    // Lekérjük a fájl tartalmát és feldolgozzuk
    const fileContent = this.dataService.getFileContent();
    this.tableData = this.parseFileContent(fileContent);
  }

  // A fájl tartalmának feldolgozása
  parseFileContent(content: string): any[] {
    const rows = content.split('\n'); // Sorokra bontjuk a fájlt
    return rows.map(row => row.split(';')); // Minden sort oszlopokra bontunk
  }

  // Új üres sor hozzáadása
  addRow() {
    this.tableData.push(['', '', '', '', '']);
  }

  // Sor törlése
  deleteRow(index: number) {
    this.tableData.splice(index, 1); // A megadott indexű sort töröljük
  }

  // Adatok mentése (pl. később szolgáltatáson keresztül lehet küldeni)
  saveData() {
    const formattedData = this.tableData.map(row => row.join(';')).join('\n');
    console.log('Mentett adatok:', formattedData);
    // Ezt akár vissza is küldheted a DataService-be, ha menteni szeretnéd
    this.dataService.setFileContent(formattedData);
  }
}

<table>
  <thead>
    <tr>
      <th>Column 1</th>
      <th>Column 2</th>
      <th>Column 3</th>
      <th>Column 4</th>
      <th>Column 5</th>
      <th>Actions</th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let row of tableData; let i = index">
      <td><input [(ngModel)]="row[0]" /></td>
      <td><input [(ngModel)]="row[1]" /></td>
      <td><input [(ngModel)]="row[2]" /></td>
      <td><input [(ngModel)]="row[3]" /></td>
      <td><input [(ngModel)]="row[4]" /></td>
      <td>
        <button (click)="deleteRow(i)">Delete</button>
      </td>
    </tr>
  </tbody>
</table>

<button (click)="addRow()">Add Row</button>
<button (click)="saveData()">Save</button>


app.module.ts -> formsmodule import

//

import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html',
  styleUrls: ['./file-upload.component.css']
})
export class FileUploadComponent {

  file1: File | null = null;
  file2: File | null = null;

  constructor(private http: HttpClient) {}

  // Fájl kiválasztása
  onFileChange(event: any, fileKey: string) {
    const file = event.target.files[0];
    if (fileKey === 'file1') {
      this.file1 = file;
    } else if (fileKey === 'file2') {
      this.file2 = file;
    }
  }

  // Fájlok feltöltése a backend felé
  onSubmit() {
    if (this.file1 && this.file2) {
      const formData = new FormData();
      formData.append('file1', this.file1);
      formData.append('file2', this.file2);

      // HTTP POST kérés a backendhez
      this.http.post('http://localhost:8080/upload', formData).subscribe(response => {
        console.log('Server response:', response);
        if (response['status'] === 'success') {
          console.log('Fájlok sikeresen ellenőrizve!');
        }
      });
    }
  }
}


import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController {

    @PostMapping("/upload")
    public ResponseEntity<?> handleFileUpload(
            @RequestParam("file1") MultipartFile file1,
            @RequestParam("file2") MultipartFile file2) {
        try {
            // Fájlok tartalmának kiolvasása
            String file1Content = new String(file1.getBytes());
            String file2Content = new String(file2.getBytes());

            // Tartalom ellenőrzése (itt implementáld az ellenőrzési logikát)
            if (file1Content.equals(file2Content)) {
                // Ha a tartalom sikeres
                return ResponseEntity.ok().body("{\"status\":\"success\"}");
            } else {
                // Hiba esetén
                return ResponseEntity.badRequest().body("{\"status\":\"error\", \"message\":\"A fájlok nem egyeznek.\"}");
            }
        } catch (Exception e) {
            return ResponseEntity.status(500).body("{\"status\":\"error\", \"message\":\"Hiba történt a fájl feltöltése közben.\"}");
        }
    }
}

this.http.post('http://localhost:8080/upload', formData).subscribe(response => {
  if (response['status'] === 'success') {
    // Ha szükséges, újraküldés logika itt
    console.log('Fájlok ellenőrzése sikeres.');
  } else {
    console.error('Fájlok ellenőrzése sikertelen.');
  }
});

//paginator

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;

import java.util.ArrayList;
import java.util.List;

@RestController
public class FileUploadController {

    private final List<String> fileContents = new ArrayList<>(); // Tároljuk a fájlok tartalmát

    @PostMapping("/upload")
    public ResponseEntity<?> handleFileUpload(
            @RequestParam("file1") MultipartFile file1,
            @RequestParam("file2") MultipartFile file2) {
        try {
            // Fájlok tartalmának tárolása
            String file1Content = new String(file1.getBytes());
            String file2Content = new String(file2.getBytes());
            
            // Mentés a fájl tartalmát (akár DB-be is lehetne)
            fileContents.add(file1Content);
            fileContents.add(file2Content);

            return ResponseEntity.ok().body("{\"status\":\"success\"}");
        } catch (Exception e) {
            return ResponseEntity.status(500).body("{\"status\":\"error\", \"message\":\"Hiba történt a fájl feltöltése közben.\"}");
        }
    }

    // Lapozott lekérdezés
    @GetMapping("/file-content")
    public Page<String> getFileContent(@RequestParam int page, @RequestParam int size) {
        int start = page * size;
        int end = Math.min((page + 1) * size, fileContents.size());
        List<String> pageContent = fileContents.subList(start, end);
        
        return new PageImpl<>(pageContent, PageRequest.of(page, size), fileContents.size());
    }
}

angular

<div *ngFor="let content of fileContents">
  <p>{{ content }}</p>
</div>

<mat-paginator [length]="totalElements" [pageSize]="pageSize" [pageSizeOptions]="[5, 10, 25]" (page)="onPageChange($event)">
</mat-paginator>

import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { PageEvent } from '@angular/material/paginator';

@Component({
  selector: 'app-file-list',
  templateUrl: './file-list.component.html',
  styleUrls: ['./file-list.component.css']
})
export class FileListComponent implements OnInit {
  
  fileContents: string[] = [];   // Fájlok tartalma
  totalElements: number = 0;     // Összes elem
  pageSize: number = 5;          // Oldalméret
  pageIndex: number = 0;         // Jelenlegi oldal

  constructor(private http: HttpClient) {}

  ngOnInit(): void {
    this.loadPage(this.pageIndex, this.pageSize); // Első oldal betöltése
  }

  // Adatok betöltése a backendről
  loadPage(page: number, size: number) {
    this.http.get<any>(`http://localhost:8080/file-content?page=${page}&size=${size}`)
      .subscribe(response => {
        this.fileContents = response.content; // Lapozott adatok
        this.totalElements = response.totalElements; // Összes elem száma
      });
  }

  // Page változás
  onPageChange(event: PageEvent) {
    this.pageIndex = event.pageIndex;
    this.pageSize = event.pageSize;
    this.loadPage(this.pageIndex, this.pageSize);
  }
}

//importalas
import { MatPaginatorModule } from '@angular/material/paginator';
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  declarations: [
    FileListComponent
  ],
  imports: [
    HttpClientModule,
    MatPaginatorModule
  ],
  providers: [],
  bootstrap: [FileListComponent]
})
export class AppModule { }

//cs

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-pagination-table',
  templateUrl: './pagination-table.component.html',
  styleUrls: ['./pagination-table.component.css']
})
export class PaginationTableComponent implements OnInit {
  rows: string[] = [
    "1;1,1;2000-01-01;1,1",
    "2;2,2;2001-01-01;2,2",
    "3;3,3;2002-01-01;3,3"
  ];

  // Az adatok feldolgozása: a sorokat szétszedjük a ';' alapján
  tableData: string[][] = [];

  ngOnInit() {
    this.tableData = this.rows.map(row => row.split(';'));
  }
}


<table>
  <thead>
    <tr>
      <th>Oszlop 1</th>
      <th>Oszlop 2</th>
      <th>Oszlop 3</th>
      <th>Oszlop 4</th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let row of tableData">
      <td *ngFor="let cell of row">{{ cell }}</td>
    </tr>
  </tbody>
</table>


//output

package com.example.demo.model;

import java.util.List;

public class PersonSchedule {
    private int personId;
    private List<String> dates;

    // Konstruktor
    public PersonSchedule(int personId, List<String> dates) {
        this.personId = personId;
        this.dates = dates;
    }

    // Getterek és setterek
    public int getPersonId() {
        return personId;
    }

    public void setPersonId(int personId) {
        this.personId = personId;
    }

    public List<String> getDates() {
        return dates;
    }

    public void setDates(List<String> dates) {
        this.dates = dates;
    }
}


package com.example.demo.service;

import com.example.demo.model.PersonSchedule;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;

@Service
public class ScheduleService {

    // Adatok generálása (itt lehet adatbázis kapcsolatot is létrehozni)
    public List<PersonSchedule> getPersonSchedules() {
        return Arrays.asList(
            new PersonSchedule(1, Arrays.asList("2024-01-01", "2024-01-02")),
            new PersonSchedule(2, Arrays.asList("2024-01-03", "2024-01-04")),
            new PersonSchedule(3, Arrays.asList("2024-01-02", "2024-01-05"))
        );
    }
}
package com.example.demo.controller;

import com.example.demo.model.PersonSchedule;
import com.example.demo.service.ScheduleService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class ScheduleController {

    private final ScheduleService scheduleService;

    // Konstruktor
    public ScheduleController(ScheduleService scheduleService) {
        this.scheduleService = scheduleService;
    }

    // Endpoint az adatok lekéréséhez
    @GetMapping("/api/schedules")
    public List<PersonSchedule> getSchedules() {
        return scheduleService.getPersonSchedules();
    }
}

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

export interface PersonSchedule {
  personId: number;
  dates: string[];
}

@Injectable({
  providedIn: 'root'
})
export class ScheduleService {

  private apiUrl = 'http://localhost:8080/api/schedules';

  constructor(private http: HttpClient) {}

  getPersonSchedules(): Observable<PersonSchedule[]> {
    return this.http.get<PersonSchedule[]>(this.apiUrl);
  }
}

import { Component, OnInit } from '@angular/core';
import { ScheduleService, PersonSchedule } from './schedule.service';

@Component({
  selector: 'app-calendar-table',
  templateUrl: './calendar-table.component.html',
  styleUrls: ['./calendar-table.component.css']
})
export class CalendarTableComponent implements OnInit {
  personSchedules: PersonSchedule[] = [];
  days: string[] = [];
  startDate: string = '2024-01-01';
  numberOfDays: number = 7; // pl. egy hét

  constructor(private scheduleService: ScheduleService) {}

  ngOnInit() {
    this.generateDays(this.startDate, this.numberOfDays);
    this.loadSchedules();
  }

  generateDays(startDate: string, numberOfDays: number) {
    const start = new Date(startDate);
    for (let i = 0; i < numberOfDays; i++) {
      const day = new Date(start);
      day.setDate(start.getDate() + i);
      this.days.push(day.toISOString().split('T')[0]);
    }
  }

  loadSchedules() {
    this.scheduleService.getPersonSchedules().subscribe(data => {
      this.personSchedules = data;
    });
  }

  isDaySelected(personId: number, day: string): boolean {
    const person = this.personSchedules.find(d => d.personId === personId);
    return person ? person.dates.includes(day) : false;
  }
}

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th *ngFor="let day of days">{{ day }}</th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let person of data">
      <td>{{ person[0] }}</td> <!-- Az ember indexe -->
      <td *ngFor="let day of days" [ngStyle]="{'background-color': isDaySelected(person[0], day) ? 'lightgreen' : 'white'}">
        <!-- Kiszínezett cella, ha a nap szerepel -->
      </td>
    </tr>
  </tbody>
</table>


//k

public class RowData {
    private List<Integer> values;

    public RowData(List<Integer> values) {
        this.values = values;
    }

    public List<Integer> getValues() {
        return values;
    }

    public void setValues(List<Integer> values) {
        this.values = values;
    }
}

import java.util.ArrayList;
import java.util.List;

public class MyObject {
    private String data; // String formátuma: "1;1;1;1\n2;2;2;2"

    public MyObject(String data) {
        this.data = data;
    }

    // Adatok feldarabolása \n és ; mentén
    public List<RowData> getParsedData() {
        List<RowData> result = new ArrayList<>();
        String[] rows = data.split("\n");

        for (String row : rows) {
            String[] parts = row.split(";");
            List<Integer> rowValues = new ArrayList<>();
            for (String part : parts) {
                rowValues.add(Integer.parseInt(part));
            }
            result.add(new RowData(rowValues)); // Minden sor RowData objektum lesz
        }

        return result;
    }
}

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
public class MyController {

    // Példa API endpoint a feldolgozott adatok visszaküldésére
    @GetMapping("/api/data")
    public Map<Integer, List<RowData>> getData() {
        Map<Integer, MyObject> map = new HashMap<>();
        // Feltöltés példa adattal
        map.put(1, new MyObject("1;1;1;1\n2;2;2;2\n3;3;3;3"));

        Map<Integer, List<RowData>> result = new HashMap<>();
        for (Map.Entry<Integer, MyObject> entry : map.entrySet()) {
            result.put(entry.getKey(), entry.getValue().getParsedData());
        }

        return result; // JSON formátumban visszaküldi a 2D objektum struktúrát
    }
}

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {

  constructor(private http: HttpClient) { }

  // API-ról adatok lekérése
  getData(): Observable<{[key: number]: RowData[]}> {
    return this.http.get<{[key: number]: RowData[]}>('/api/data');
  }
}

// RowData interfész, ami a kapott objektumot reprezentálja
export interface RowData {
  values: number[];
}

import { Component, OnInit } from '@angular/core';
import { DataService, RowData } from './data.service';

@Component({
  selector: 'app-data',
  template: `
    <div *ngFor="let key of keys">
      <h3>Kulcs: {{key}}</h3>
      <div *ngFor="let row of data[key]">
        <p>Értékek: {{row.values.join(', ')}}</p>
      </div>
    </div>
  `
})
export class DataComponent implements OnInit {
  data: {[key: number]: RowData[]} = {};
  keys: number[] = [];

  constructor(private dataService: DataService) { }

  ngOnInit(): void {
    this.dataService.getData().subscribe(response => {
      this.data = response;
      this.keys = Object.keys(this.data).map(key => +key); // Kulcsok listázása
    });
  }
}


//id sor

public class MyObject {
    private int id;
    private String data1; // Az első string
    private String data2; // A második string

    public MyObject(int id, String data1, String data2) {
        this.id = id;
        this.data1 = data1;
        this.data2 = data2;
    }

    // Getterek és setterek
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getData1() {
        return data1;
    }

    public void setData1(String data1) {
        this.data1 = data1;
    }

    public String getData2() {
        return data2;
    }

    public void setData2(String data2) {
        this.data2 = data2;
    }
}

import java.util.HashMap;
import java.util.Map;

public class MyObjectStorage {
    private Map<Integer, MyObject> objectMap = new HashMap<>();

    // Példa adat feltöltése a map-be
    public MyObjectStorage() {
        objectMap.put(1, new MyObject(1, "1;1;1;1", "2;2;2;2"));
        objectMap.put(2, new MyObject(2, "3;3;3;3", "4;4;4;4"));
        objectMap.put(3, new MyObject(3, "5;5;5;5", "6;6;6;6"));
    }

    // Objektum lekérése az id alapján
    public MyObject getObjectById(int id) {
        return objectMap.get(id);
    }
    
    // Az összes objektum visszaadása
    public Map<Integer, MyObject> getAllObjects() {
        return objectMap;
    }
}


import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

@RestController
public class MyController {

    private MyObjectStorage storage = new MyObjectStorage();

    // Egyedi objektum visszaadása ID alapján
    @GetMapping("/api/object/{id}")
    public MyObject getObjectById(@PathVariable int id) {
        return storage.getObjectById(id);
    }

    // Összes objektum visszaadása
    @GetMapping("/api/objects")
    public Map<Integer, MyObject> getAllObjects() {
        return storage.getAllObjects();
    }
}


import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

// MyObject interfész
export interface MyObject {
  id: number;
  data1: string;
  data2: string;
}

@Injectable({
  providedIn: 'root'
})
export class DataService {

  constructor(private http: HttpClient) { }

  // Egy objektum lekérése az ID alapján
  getObjectById(id: number): Observable<MyObject> {
    return this.http.get<MyObject>(`/api/object/${id}`);
  }

  // Az összes objektum lekérése
  getAllObjects(): Observable<{ [key: number]: MyObject }> {
    return this.http.get<{ [key: number]: MyObject }>('/api/objects');
  }
}


import { Component, OnInit } from '@angular/core';
import { DataService, MyObject } from './data.service';

@Component({
  selector: 'app-data',
  template: `
    <div *ngFor="let obj of objects">
      <h3>ID: {{obj.id}}</h3>
      <p>Data 1: {{obj.data1}}</p>
      <p>Data 2: {{obj.data2}}</p>
    </div>
  `
})
export class DataComponent implements OnInit {
  objects: MyObject[] = [];

  constructor(private dataService: DataService) { }

  ngOnInit(): void {
    // Az összes objektum lekérése és megjelenítése
    this.dataService.getAllObjects().subscribe(response => {
      this.objects = Object.values(response);
    });
  }
}





