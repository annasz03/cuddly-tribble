<label for="date-input">Select Day:</label>
<input type="date" id="date-input" name="date-input">

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0'); 

    const dateInput = document.getElementById('date-input');


    dateInput.min = `${year}-${month}-01`;
    dateInput.max = `${year}-${month}-31`; // Maximum nap 31, de a böngésző automatikusan kezeli a hónap hosszát


    dateInput.value = `${year}-${month}-${day}`;
  });
</script>


//spring boot

package com.example.demo.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class HelloWorldController {

    @GetMapping("/hello")
    public String sayHello() {
        return "Hello from Java backend!";
    }
}


//cors
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:4200")  // Angular alkalmazás URL-je
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}

httpclientmodule import app-ba

ng generate service data
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {

  private apiUrl = 'http://localhost:8080/api/hello';

  constructor(private http: HttpClient) { }

  getHelloMessage(): Observable<string> {
    return this.http.get(this.apiUrl, { responseType: 'text' });
  }
}

import { Component, OnInit } from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'app-root',
  template: `<h1>{{ message }}</h1>`,
})
export class AppComponent implements OnInit {
  message: string;

  constructor(private dataService: DataService) {}

  ngOnInit(): void {
    this.dataService.getHelloMessage().subscribe(response => {
      this.message = response;
    });
  }
}

///

<form [formGroup]="uploadForm" (ngSubmit)="onSubmit()">
  <input type="file" formControlName="file" (change)="onFileSelect($event)" />
  <button type="submit">Upload</button>
</form>

import { Component } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html',
})
export class FileUploadComponent {
  uploadForm: FormGroup;
  selectedFile: File;

  constructor(private formBuilder: FormBuilder, private http: HttpClient) {
    this.uploadForm = this.formBuilder.group({
      file: ['']
    });
  }

  onFileSelect(event) {
    this.selectedFile = event.target.files[0];
  }

  onSubmit() {
    const formData = new FormData();
    formData.append('file', this.selectedFile);

    this.http.post('http://localhost:8080/upload', formData).subscribe(
      (response) => console.log(response),
      (error) => console.error(error)
    );
  }
}

spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB


//filet elkuldi backendnek

import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html',
})
export class FileUploadComponent {
  constructor(private http: HttpClient) {}

  createAndSendFile() {
    // Fájl tartalma
    const fileContent = 'Ez egy teszt fájl tartalma.';
    
    // Fájl létrehozása Blob segítségével
    const blob = new Blob([fileContent], { type: 'text/plain' });

    // Fájl névvel való ellátása
    const file = new File([blob], 'testfile.txt', { type: 'text/plain' });

    // FormData létrehozása és a fájl hozzáadása
    const formData = new FormData();
    formData.append('file', file);

    // Fájl elküldése a backendre
    this.http.post('http://localhost:8080/upload', formData).subscribe(
      (response) => console.log(response),
      (error) => console.error(error)
    );
  }
}


<button (click)="createAndSendFile()">Create and Upload File</button>


@PostMapping("/upload")
public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {
    if (file.isEmpty()) {
        return new ResponseEntity<>("Please select a file to upload", HttpStatus.BAD_REQUEST);
    }

    try {
        byte[] bytes = file.getBytes();
        Path path = Paths.get("uploads/" + file.getOriginalFilename());
        Files.write(path, bytes);

        return new ResponseEntity<>("File uploaded successfully: " + file.getOriginalFilename(), HttpStatus.OK);
    } catch (IOException e) {
        return new ResponseEntity<>("File upload failed: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

//append

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@RestController
public class FileUploadController {

    private static final String UPLOAD_DIR = "uploads/";
    private static final String TARGET_FILE_NAME = "merged_file.txt"; // A cél fájl neve

    @PostMapping("/upload")
    public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {
        if (file.isEmpty()) {
            return new ResponseEntity<>("Please select a file to upload", HttpStatus.BAD_REQUEST);
        }

        try {
            // Cél fájl elérési útvonala
            Path targetPath = Paths.get(UPLOAD_DIR + TARGET_FILE_NAME);
            
            // Ha a fájl nem létezik, létrehozzuk
            if (!Files.exists(targetPath)) {
                Files.createFile(targetPath);
            }

            // Fájl tartalmának hozzáfűzése a meglévő fájlhoz
            try (FileOutputStream fos = new FileOutputStream(new File(targetPath.toString()), true)) {
                fos.write(file.getBytes());
                fos.write(System.lineSeparator().getBytes()); // Új sor hozzáadása minden egyes fájl végén
            }

            return new ResponseEntity<>("File content appended successfully to: " + TARGET_FILE_NAME, HttpStatus.OK);
        } catch (IOException e) {
            return new ResponseEntity<>("File upload failed: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}

//parse

import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class MyService {

  constructor(private http: HttpClient) { }

  sendData() {
    const headers = new HttpHeaders({ 'Content-Type': 'text/plain' });
    const body = '1;1;1';

    this.http.post('http://localhost:8080/api/postsofor', body, { headers, responseType: 'text' })
      .subscribe(
        response => {
          console.log('Response:', response);
        },
        error => {
          console.error('Error:', error);
        }
      );
  }
}

//vissza kuldes

import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class FileController {

    @GetMapping("/download-file")
    public ResponseEntity<Resource> downloadFile() {
        try {
            // Fájl betöltése az erőforrások közül (pl. classpath-ból)
            Resource file = new ClassPathResource("static/sample.txt");

            // HTTP válasz beállítása: fájl küldése szöveges típusúként
            return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + file.getFilename() + "\"")
                .body(file);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
}


import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class FileController {

    @GetMapping("/download-file")
    public ResponseEntity<Resource> downloadFile() {
        try {
            Resource file = new ClassPathResource("static/sample.txt");

            return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + file.getFilename() + "\"")
                .body(file);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
}

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class FileDownloadService {

  constructor(private http: HttpClient) { }

  downloadFileContent() {
    this.http.get('http://localhost:8080/api/download-file', { responseType: 'blob' })
      .subscribe(
        (response: Blob) => {
          this.readFileContent(response);
        },
        error => {
          console.error('Error downloading file:', error);
        }
      );
  }

  // Fájl tartalmának beolvasása változóba
  private readFileContent(blob: Blob) {
    const reader = new FileReader();
    reader.onload = () => {
      const fileContent = reader.result as string;  // A fájl tartalma stringként
      console.log('File content:', fileContent);    // Itt dolgozhatsz a tartalommal
    };
    reader.readAsText(blob);  // Ha a fájl szöveg, használjuk a readAsText metódust
  }
}

//fileba ira

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Arrays;

public class FileWriteExample {
    public static void main(String[] args) {
        Path filePath = Paths.get("output.txt");  // Fájl elérési útvonala

        // Adatok, amelyeket írni szeretnénk
        List<String> lines = Arrays.asList("Sor 1", "Sor 2", "Sor 3");

        try {
            // Írás a fájlba
            Files.write(filePath, lines, StandardCharsets.UTF_8);
            System.out.println("Fájlba írás sikeres!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

//file feltoltes

// file-upload.interface.ts
export interface FileUpload {
  file1: string;  // Base64 formátumban az első fájl
  file2: string;  // Base64 formátumban a második fájl
}


<form (submit)="onSubmit()">
  <label for="file1">Fájl 1:</label>
  <input type="file" id="file1" (change)="onFileSelected($event, 'file1')" />

  <label for="file2">Fájl 2:</label>
  <input type="file" id="file2" (change)="onFileSelected($event, 'file2')" />

  <button type="submit">Fájlok elküldése</button>
</form>

// file-upload.component.ts
import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { FileUpload } from './file-upload.interface';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html'
})
export class FileUploadComponent {
  fileData: FileUpload = { file1: '', file2: '' };

  constructor(private http: HttpClient) {}

  onFileSelected(event: Event, fileTag: string): void {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files[0]) {
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = () => {
        const base64String = reader.result as string;
        if (fileTag === 'file1') {
          this.fileData.file1 = base64String.split(',')[1]; // Base64 tartalom leválasztása
        } else if (fileTag === 'file2') {
          this.fileData.file2 = base64String.split(',')[1];
        }
      };
      reader.readAsDataURL(file); // Base64-re konvertálás
    }
  }

  onSubmit(): void {
    this.http.post('http://localhost:8080/api/upload', this.fileData)
      .subscribe(response => {
        console.log('Fájlok sikeresen elküldve!', response);
      }, error => {
        console.error('Hiba a fájlok elküldésekor:', error);
      });
  }
}

// FileUploadDto.java
public class FileUploadDto {
    private String file1;
    private String file2;

    // Getters and setters
    public String getFile1() {
        return file1;
    }

    public void setFile1(String file1) {
        this.file1 = file1;
    }

    public String getFile2() {
        return file2;
    }

    public void setFile2(String file2) {
        this.file2 = file2;
    }
}

// FileUploadController.java
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class FileUploadController {

    @PostMapping("/upload")
    public ResponseEntity<String> uploadFiles(@RequestBody FileUploadDto fileUploadDto) {
        // A fájlok feldolgozása itt történik
        System.out.println("File 1 (Base64): " + fileUploadDto.getFile1());
        System.out.println("File 2 (Base64): " + fileUploadDto.getFile2());

        // Például a fájlokat kiírhatjuk a fájlrendszerbe vagy adatbázisba menthetjük
        // Base64-dekódolásra is szükség lehet (nem mutatott itt)

        return ResponseEntity.ok("Fájlok sikeresen fogadva!");
    }
}

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Base64;

@RestController
@RequestMapping("/api")
public class FileUploadController {

    @PostMapping("/upload")
    public ResponseEntity<String> uploadFiles(@RequestBody FileUploadDto fileUploadDto) {
        try {
            // Fájl 1 dekódolása és mentése
            byte[] decodedFile1 = Base64.getDecoder().decode(fileUploadDto.getFile1());
            try (FileOutputStream fos = new FileOutputStream("output_file1.txt")) {
                fos.write(decodedFile1);
            }

            // Fájl 2 dekódolása és mentése
            byte[] decodedFile2 = Base64.getDecoder().decode(fileUploadDto.getFile2());
            try (FileOutputStream fos = new FileOutputStream("output_file2.txt")) {
                fos.write(decodedFile2);
            }

            System.out.println("Fájlok sikeresen mentve!");

            return ResponseEntity.ok("Fájlok sikeresen fogadva és mentve!");

        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(500).body("Hiba történt a fájlok mentésekor.");
        }
    }
}

//h

<!-- file-upload.component.html -->
<form>
  <label for="file1">Fájl 1:</label>
  <input type="file" id="file1" (change)="onFileSelected($event, 'file1')" />

  <label for="file2">Fájl 2:</label>
  <input type="file" id="file2" (change)="onFileSelected($event, 'file2')" />

  <!-- A submit gomb csak akkor jelenik meg, ha mindkét fájl fel van töltve -->
  <button *ngIf="bothFilesUploaded()" (click)="onSubmit()">Fájlok elküldése</button>
</form>

// file-upload.component.ts
import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { FileUpload } from './file-upload.interface';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html'
})
export class FileUploadComponent {
  fileData: FileUpload = { file1: '', file2: '' };

  constructor(private http: HttpClient) {}

  // Fájlfeltöltés kezelése
  onFileSelected(event: Event, fileTag: string): void {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files[0]) {
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = () => {
        const base64String = reader.result as string;
        if (fileTag === 'file1') {
          this.fileData.file1 = base64String.split(',')[1]; // Base64 tartalom leválasztása
        } else if (fileTag === 'file2') {
          this.fileData.file2 = base64String.split(',')[1];
        }
      };
      reader.readAsDataURL(file); // Base64 konvertálás
    }
  }

  // Ellenőrzi, hogy mindkét fájl fel van-e töltve
  bothFilesUploaded(): boolean {
    return this.fileData.file1 !== '' && this.fileData.file2 !== '';
  }

  // Adatok elküldése a backendnek
  onSubmit(): void {
    this.http.post('http://localhost:8080/api/upload', this.fileData)
      .subscribe(response => {
        console.log('Fájlok sikeresen elküldve!', response);
      }, error => {
        console.error('Hiba a fájlok elküldésekor:', error);
      });
  }
}

import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-file-upload',
  templateUrl: './file-upload.component.html'
})
export class FileUploadComponent {
  file1: string = ''; // Az első fájl Base64 formátumban
  file2: string = ''; // A második fájl Base64 formátumban

  constructor(private http: HttpClient) {}

  // Fájlfeltöltés kezelése
  onFileSelected(event: Event): void {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files[0]) {
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = () => {
        const base64String = reader.result as string;

        // Ha még nincs fájl feltöltve, az első fájlként tároljuk
        if (!this.file1) {
          this.file1 = base64String.split(',')[1]; // Base64 tartalom leválasztása
        } else if (!this.file2) {
          // Ha már van egy fájl feltöltve, a második fájlként tároljuk
          this.file2 = base64String.split(',')[1];
        }
      };
      reader.readAsDataURL(file);
    }
  }

  // Ellenőrzi, hogy mindkét fájl fel van-e töltve
  bothFilesUploaded(): boolean {
    return this.file1 !== '' && this.file2 !== '';
  }

  // Adatok elküldése a backendnek
  onSubmit(): void {
    const fileData = {
      file1: this.file1,
      file2: this.file2
    };

    this.http.post('http://localhost:8080/api/upload', fileData)
      .subscribe(response => {
        console.log('Fájlok sikeresen elküldve!', response);
      }, error => {
        console.error('Hiba a fájlok elküldésekor:', error);
      });
  }
}

<!-- file-upload.component.html -->
<form>
  <label for="file">Válassz fájlokat:</label>
  <input type="file" id="file" (change)="onFileSelected($event)" multiple />

  <!-- A submit gomb csak akkor jelenik meg, ha mindkét fájl fel van töltve -->
  <button *ngIf="bothFilesUploaded()" (click)="onSubmit()">Fájlok elküldése</button>
</form>


//k

import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

public class StringFormatValidator {

    // Regex to match a valid date in format YYYY-MM-DD
    private static final Pattern YEAR_PATTERN = Pattern.compile("\\d{4}-\\d{2}-\\d{2}");
    
    // Method to validate the entire string structure
    public boolean validate(String input) {
        // Split input by semicolons
        String[] parts = input.split(";");

        if (parts.length != 4) {
            return false; // Ensure the input has exactly 4 parts
        }

        // Validate first part: a list of year strings
        if (!parts[0].startsWith("[") || !parts[0].endsWith("]")) {
            return false;
        }
        String firstPartContent = parts[0].substring(1, parts[0].length() - 1); // Remove square brackets
        List<String> firstPart = Arrays.asList(firstPartContent.split(","));
        for (String year : firstPart) {
            if (!YEAR_PATTERN.matcher(year.trim()).matches()) {
                return false; // Each item should be a valid year in YYYY-MM-DD format
            }
        }

        // Validate second part: a list of integers
        if (!parts[1].startsWith("[") || !parts[1].endsWith("]")) {
            return false;
        }
        String secondPartContent = parts[1].substring(1, parts[1].length() - 1); // Remove square brackets
        List<String> secondPart = Arrays.asList(secondPartContent.split(","));
        for (String number : secondPart) {
            try {
                Integer.parseInt(number.trim()); // Each item should be a valid integer
            } catch (NumberFormatException e) {
                return false;
            }
        }

        // Validate third part: a single integer
        try {
            Integer.parseInt(parts[2].trim());
        } catch (NumberFormatException e) {
            return false;
        }

        // Validate fourth part: a single year in YYYY-MM-DD format
        if (!YEAR_PATTERN.matcher(parts[3].trim()).matches()) {
            return false;
        }

        // If all checks pass, return true
        return true;
    }

    public static void main(String[] args) {
        StringFormatValidator validator = new StringFormatValidator();
        
        // Example input
        String validInput = "[2003-01-01, 2004-01-01];[11];1;2004-01-01";
        
        boolean isValid = validator.validate(validInput);
        System.out.println("Is valid: " + isValid); // Should print true or false based on validation
    }
}





